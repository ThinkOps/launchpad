#!/usr/bin/env bash
# Guided installer for Launchpad self-hosted deployment
set -u

START_TS=$(date +%Y-%m-%d-%H-%M-%S)
INSTALL_REPORT="installation-report.txt"
PREREQ_FILE="prerequisites.txt"
MODE=""
ENV_FILE=""

log() { echo "[$(date +%H:%M:%S)] $*" | tee -a "$INSTALL_REPORT"; }
warn() { log "WARN: $*"; }
err()  { log "ERROR: $*"; }

# Compare versions: version_gte A B => true if A >= B
version_gte() {
  # usage: version_gte 20.10 20.10
  [ "$(printf '%s\n' "$2" "$1" | sort -V | head -n1)" = "$2" ]
}

need_prereqs=false

check_cmd() {
  local cmd="$1" minver="$2" vercmd="$3" parse="${4:-}"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    err "$cmd not found"
    need_prereqs=true
    return
  fi
  if [[ -n "$minver" ]]; then
    local out
    out=$(eval "$vercmd" 2>/dev/null || true)
    local ver
    if [[ -n "$parse" ]]; then ver=$(echo "$out" | eval "$parse"); else ver="$out"; fi
    log "$cmd version: $ver (required >= $minver)"
    if ! version_gte "$ver" "$minver"; then
      err "$cmd version too low: $ver < $minver"
      need_prereqs=true
    fi
  else
    log "$cmd present"
  fi
}

check_ports() {
  local ports=(80 443 3000 9000)
  for p in "${ports[@]}"; do
    if lsof -i -P -n | grep -E ":$p\s" >/dev/null 2>&1; then
      warn "Port $p appears to be in use"
    else
      log "Port $p is available"
    fi
  done
}

write_prereqs() {
  cat > "$PREREQ_FILE" <<'EOF'
Prerequisites not met. Install the following before running ./install.sh again:

Docker (>= 20.10)
Docker Compose (>= 2.0)
curl
lsof

macOS (Homebrew):
  brew install --cask docker
  open -a Docker.app  # start Docker Desktop, wait until running

Ubuntu/Debian:
  sudo apt-get update
  sudo apt-get install -y docker.io docker-compose-plugin curl lsof
  sudo usermod -aG docker "$USER" # then log out/in

Verification:
  docker --version
  docker compose version
  curl --version
  lsof -v
EOF
  log "Wrote $PREREQ_FILE with installation instructions."
}

prompt() {
  local var="$1" msg="$2" def="${3:-}" secret="${4:-false}"
  local val
  while true; do
    if $secret; then
      read -r -s -p "$msg${def:+ [$def]}: " val; echo
    else
      read -r -p "$msg${def:+ [$def]}: " val
    fi
    val=${val:-$def}
    if [[ -n "$val" ]]; then
      printf -v "$var" '%s' "$val"
      return 0
    fi
    echo "Please enter a value."
  done
}

validate_google_client_id() {
  [[ "$1" =~ \.apps\.googleusercontent\.com$ ]]
}

autogen_secret() {
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -base64 48 | tr -d '\n'
  else
    head -c 48 /dev/urandom | base64 | tr -d '\n'
  fi
}

create_env_file() {
  local path="$1" mode="$2" jwt google db_user db_pass db_name db_root caddy_domain caddy_email
  # JWT
  while true; do
    prompt jwt "Enter JWT_SECRET (>=32 chars; leave empty to auto-generate)" ""
    if [[ -z "$jwt" ]]; then jwt=$(autogen_secret); fi
    if ((${#jwt} >= 32)); then break; else echo "JWT_SECRET too short."; fi
  done
  # Google client id
  while true; do
    prompt google "Enter GOOGLE_CLIENT_ID (e.g., 12345-xxxxx.apps.googleusercontent.com)" ""
    if validate_google_client_id "$google"; then break; else echo "Invalid GOOGLE_CLIENT_ID format."; fi
  done
  prompt db_user  "DB username" "launchpad"
  prompt db_pass  "DB password" "launchpad" true
  prompt db_name  "DB name"     "launchpad"
  prompt db_root  "MySQL root password" "root" true
  if [[ "$mode" == "production" ]]; then
    prompt caddy_domain "CADDY_DOMAIN (your domain)" "example.com"
    prompt caddy_email  "CADDY_EMAIL (for Let's Encrypt)" "admin@example.com"
  else
    caddy_domain="localhost"; caddy_email="admin@example.com"
  fi

  cat > "$path" <<EOF
# Generated by install.sh at ${START_TS}
MYSQL_ROOT_PASSWORD=$db_root
MYSQL_DATABASE=$db_name
MYSQL_USER=$db_user
MYSQL_PASSWORD=$db_pass

DB_MASTER_HOST=lp-mysql
DB_READER_HOST=lp-mysql
DB_PORT=3306
DB_USERNAME=$db_user
DB_PASSWORD=$db_pass
DB_NAME=$db_name
DB_LOGGING=false

JWT_SECRET=$jwt
GOOGLE_CLIENT_ID=$google

REACT_APP_ENV=${mode}

CADDY_DOMAIN=$caddy_domain
CADDY_EMAIL=$caddy_email
EOF
  log ".env written to $path"
}

select_mode() {
  while true; do
    echo "Select deployment mode:"; echo "  1) Development (HTTP, direct ports)"; echo "  2) Production (reverse proxy only, HTTPS-ready)"
    read -r -p "Enter 1 or 2: " choice
    case "$choice" in
      1) MODE="development"; return ;;
      2) MODE="production";  return ;;
      *) echo "Invalid selection" ;;
    esac
  done
}

# 1) Prerequisites
: > "$INSTALL_REPORT"
log "Starting Launchpad installer at $START_TS"
check_cmd docker "20.10" "docker --version | awk '{print $3}' | sed 's/,//'"
check_cmd docker "2.0" "docker compose version | awk '{print $4}' | sed 's/^v//'"
check_cmd curl "" "curl --version | head -n1"
check_cmd lsof "" "lsof -v | head -n1"
check_ports
if $need_prereqs; then
  write_prereqs
  err "Prerequisites missing or outdated. See $PREREQ_FILE"
  exit 1
fi

# 2) Environment configuration
if [[ ${1:-} == "--env-file" ]]; then
  ENV_FILE="${2:-}"
fi
if [[ -n "$ENV_FILE" ]]; then
  if [[ ! -f "$ENV_FILE" ]]; then
    err "Env file not found: $ENV_FILE"; exit 1
  fi
  log "Using provided env file: $ENV_FILE"
  # Basic validation for required keys
  for k in MYSQL_DATABASE MYSQL_USER MYSQL_PASSWORD JWT_SECRET GOOGLE_CLIENT_ID REACT_APP_ENV; do
    if ! grep -q "^$k=" "$ENV_FILE"; then err "Missing $k in $ENV_FILE"; exit 1; fi
  done
  cp "$ENV_FILE" .env
  MODE=$(grep '^REACT_APP_ENV=' "$ENV_FILE" | cut -d= -f2)
else
  select_mode
  create_env_file ".env" "$MODE"
fi

log "Deployment mode: $MODE"

# 3) Automated setup
step=1; total=5
log "[$step/$total] Starting containers"
if [[ "$MODE" == "production" ]]; then
  make up-prod | tee -a "$INSTALL_REPORT"
else
  make up | tee -a "$INSTALL_REPORT"
fi

step=$((step+1)); log "[$step/$total] Running database migrations"
make migrate | tee -a "$INSTALL_REPORT"

step=$((step+1)); log "[$step/$total] Verifying basic connectivity"
if [[ "$MODE" == "production" ]]; then
  make verify-proxy | tee -a "$INSTALL_REPORT"
else
  make verify | tee -a "$INSTALL_REPORT"
fi

step=$((step+1)); log "[$step/$total] Running smoke tests"
chmod +x ./smoke-test.sh 2>/dev/null || true
./smoke-test.sh | tee -a "$INSTALL_REPORT"
ST=$?

# 4) Wrap up
step=$((step+1)); log "[$step/$total] Finalizing"
if [[ $ST -ne 0 ]]; then
  err "Smoke tests failed. Rolling back containers (make down)."
  make down | tee -a "$INSTALL_REPORT"
  log "Troubleshooting tips:"
  log " - Check docker compose ps and logs (make logs)"
  log " - Ensure ports are free or adjust .env"
  log " - Review smoke-test report file for HTTP responses"
  log "Installation FAILED. See $INSTALL_REPORT"
  exit 1
fi

log "Installation SUCCESSFUL. Access URLs:"
if [[ "$MODE" == "production" ]]; then
  DOMAIN=$(grep '^CADDY_DOMAIN=' .env | cut -d= -f2)
  log " - App: http://$DOMAIN/ (enable TLS per reverse proxy docs)"
  log " - Health: http://$DOMAIN/health"
else
  log " - Backend: http://localhost:9000/health"
  log " - Frontend: http://localhost:3000/"
  log " - Proxy: http://localhost/ (if using reverse-proxy)"
fi

log "A summary has been recorded in $INSTALL_REPORT"
exit 0

